# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
}

interface Node {
    id: ID!
}

interface NodeConnection {
    edges: [NodeConnectionEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

interface NodeConnectionEdge {
    next: Node
    node: Node
    previous: Node
}

type Accomodation implements Node {
    belongsTo(
        filter: BelongsToFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument!],
        sortBy: String = "date"
    ): NodeBelongsTo
    content: String
    excerpt(
        "Maximum length of generated excerpt (characters)"
        length: Int = 200
    ): String
    fileInfo: Accomodation_FileInfo
    headings(depth: RemarkHeadingLevels, stripTags: Boolean = true): [RemarkHeading]
    id: ID!
    path(to: String = "default"): String
    picture(
        "Background color for 'contain'"
        background: String,
        "Blur level for base64 string"
        blur: Int,
        "Fit"
        fit: ImageFit = cover,
        "Height"
        height: Int,
        "Quality (default: 75)"
        quality: Int,
        "Width"
        width: Int
    ): Image
    timeToRead(
        "Words per minute"
        speed: Int = 230
    ): Int
    title: String
}

type AccomodationConnection implements NodeConnection {
    edges: [AccomodationEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type AccomodationEdge implements NodeConnectionEdge {
    next: Accomodation
    node: Accomodation
    previous: Accomodation
}

type Accomodation_FileInfo {
    directory: String
    extension: String
    name: String
    path: String
}

type Activity implements Node {
    belongsTo(
        filter: BelongsToFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument!],
        sortBy: String = "date"
    ): NodeBelongsTo
    content: String
    excerpt(
        "Maximum length of generated excerpt (characters)"
        length: Int = 200
    ): String
    fileInfo: Activity_FileInfo
    headings(depth: RemarkHeadingLevels, stripTags: Boolean = true): [RemarkHeading]
    id: ID!
    path(to: String = "default"): String
    picture(
        "Background color for 'contain'"
        background: String,
        "Blur level for base64 string"
        blur: Int,
        "Fit"
        fit: ImageFit = cover,
        "Height"
        height: Int,
        "Quality (default: 75)"
        quality: Int,
        "Width"
        width: Int
    ): Image
    timeToRead(
        "Words per minute"
        speed: Int = 230
    ): Int
    title: String
}

type ActivityConnection implements NodeConnection {
    edges: [ActivityEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type ActivityEdge implements NodeConnectionEdge {
    next: Activity
    node: Activity
    previous: Activity
}

type Activity_FileInfo {
    directory: String
    extension: String
    name: String
    path: String
}

type Audrey implements Node {
    belongsTo(
        filter: BelongsToFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument!],
        sortBy: String = "date"
    ): NodeBelongsTo
    content: String
    extension: String
    fileInfo: Audrey_FileInfo
    id: ID!
    name: String
    path(to: String = "default"): String
}

type AudreyConnection implements NodeConnection {
    edges: [AudreyEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type AudreyEdge implements NodeConnectionEdge {
    next: Audrey
    node: Audrey
    previous: Audrey
}

type Audrey_FileInfo {
    directory: String
    extension: String
    name: String
    path: String
}

type Mairie implements Node {
    belongsTo(
        filter: BelongsToFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument!],
        sortBy: String = "date"
    ): NodeBelongsTo
    content: String
    extension: String
    fileInfo: Mairie_FileInfo
    id: ID!
    name: String
    path(to: String = "default"): String
}

type MairieConnection implements NodeConnection {
    edges: [MairieEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type MairieEdge implements NodeConnectionEdge {
    next: Mairie
    node: Mairie
    previous: Mairie
}

type Mairie_FileInfo {
    directory: String
    extension: String
    name: String
    path: String
}

type Metadata {
    pathPrefix: String
    siteDescription: String
    siteName: String
    siteUrl: String
}

type NodeBelongsTo implements NodeConnection {
    edges: [NodeBelongsToEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type NodeBelongsToEdge implements NodeConnectionEdge {
    next: Node
    node: Node
    previous: Node
}

type Page {
    context: JSON!
    path: String!
}

type PageInfo {
    currentPage: Int!
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    isFirst: Boolean!
    isLast: Boolean!
    perPage: Int!
    totalItems: Int!
    totalPages: Int!
}

type Photobooth implements Node {
    belongsTo(
        filter: BelongsToFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument!],
        sortBy: String = "date"
    ): NodeBelongsTo
    content: String
    extension: String
    fileInfo: Photobooth_FileInfo
    id: ID!
    name: String
    path(to: String = "default"): String
}

type PhotoboothConnection implements NodeConnection {
    edges: [PhotoboothEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type PhotoboothEdge implements NodeConnectionEdge {
    next: Photobooth
    node: Photobooth
    previous: Photobooth
}

type Photobooth_FileInfo {
    directory: String
    extension: String
    name: String
    path: String
}

type Query {
    accomodation(
        id: ID,
        "Will return an error if not nullable."
        nullable: Boolean = false,
        path: String
    ): Accomodation
    activity(
        id: ID,
        "Will return an error if not nullable."
        nullable: Boolean = false,
        path: String
    ): Activity
    allAccomodation(
        "Filter for Accomodation nodes."
        filter: AccomodationFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument],
        sortBy: String = "date"
    ): AccomodationConnection
    allActivity(
        "Filter for Activity nodes."
        filter: ActivityFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument],
        sortBy: String = "date"
    ): ActivityConnection
    allAudrey(
        "Filter for Audrey nodes."
        filter: AudreyFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument],
        sortBy: String = "date"
    ): AudreyConnection
    allMairie(
        "Filter for Mairie nodes."
        filter: MairieFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument],
        sortBy: String = "date"
    ): MairieConnection
    allPage(
        "Filter pages."
        filter: PageFilterInput
    ): [Page]
    allPhotobooth(
        "Filter for Photobooth nodes."
        filter: PhotoboothFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument],
        sortBy: String = "date"
    ): PhotoboothConnection
    allTeam(
        "Filter for Team nodes."
        filter: TeamFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument],
        sortBy: String = "date"
    ): TeamConnection
    audrey(
        id: ID,
        "Will return an error if not nullable."
        nullable: Boolean = false,
        path: String
    ): Audrey
    mairie(
        id: ID,
        "Will return an error if not nullable."
        nullable: Boolean = false,
        path: String
    ): Mairie
    metaData: Metadata @deprecated(reason : "Use Query.metadata instead.")
    metadata: Metadata
    page(path: String!): Page
    photobooth(
        id: ID,
        "Will return an error if not nullable."
        nullable: Boolean = false,
        path: String
    ): Photobooth
    team(
        id: ID,
        "Will return an error if not nullable."
        nullable: Boolean = false,
        path: String
    ): Team
}

type RemarkHeading {
    anchor: String
    depth: Int
    value: String
}

type Team implements Node {
    belongsTo(
        filter: BelongsToFilterInput,
        limit: Int,
        order: SortOrder = DESC,
        page: Int,
        "Defaults to 25 when page is provided."
        perPage: Int,
        skip: Int = 0,
        sort: [SortArgument!],
        sortBy: String = "date"
    ): NodeBelongsTo
    content: String
    excerpt(
        "Maximum length of generated excerpt (characters)"
        length: Int = 200
    ): String
    fileInfo: Team_FileInfo
    headings(depth: RemarkHeadingLevels, stripTags: Boolean = true): [RemarkHeading]
    id: ID!
    mail: String
    name: String
    path(to: String = "default"): String
    picture(
        "Background color for 'contain'"
        background: String,
        "Blur level for base64 string"
        blur: Int,
        "Fit"
        fit: ImageFit = cover,
        "Height"
        height: Int,
        "Quality (default: 75)"
        quality: Int,
        "Width"
        width: Int
    ): Image
    telephone: String
    timeToRead(
        "Words per minute"
        speed: Int = 230
    ): Int
}

type TeamConnection implements NodeConnection {
    edges: [TeamEdge]
    pageInfo: PageInfo!
    totalCount: Int!
}

type TeamEdge implements NodeConnectionEdge {
    next: Team
    node: Team
    previous: Team
}

type Team_FileInfo {
    directory: String
    extension: String
    name: String
    path: String
}

enum ImageFit {
    "Embed within both provided dimensions."
    contain
    "Crop to cover both provided dimensions."
    cover
    "Ignore the aspect ratio of the input and stretch to both provided dimensions."
    fill
    "Preserving aspect ratio, resize the image to be as large as possible while ensuring its dimensions are less than or equal to both those specified."
    inside
    "Preserving aspect ratio, resize the image to be as small as possible while ensuring its dimensions are greater than or equal to both those specified. Some of these values are based on the object-fit CSS property."
    outside
}

enum RemarkHeadingLevels {
    h1
    h2
    h3
    h4
    h5
    h6
}

enum SortOrder {
    "Sort ascending"
    ASC
    "Sort descending"
    DESC
}

enum TypeName {
    Accomodation
    Activity
    Audrey
    Mairie
    Photobooth
    Team
}

input AccomodationFilterInput {
    content: StringQueryOperatorInput
    excerpt: StringQueryOperatorInput
    fileInfo: Accomodation_FileInfoFilterInput
    id: IDQueryOperatorInput
    path: StringQueryOperatorInput
    picture: ImageQueryOperatorInput
    title: StringQueryOperatorInput
}

input Accomodation_FileInfoFilterInput {
    directory: StringQueryOperatorInput
    extension: StringQueryOperatorInput
    name: StringQueryOperatorInput
    path: StringQueryOperatorInput
}

input ActivityFilterInput {
    content: StringQueryOperatorInput
    excerpt: StringQueryOperatorInput
    fileInfo: Activity_FileInfoFilterInput
    id: IDQueryOperatorInput
    path: StringQueryOperatorInput
    picture: ImageQueryOperatorInput
    title: StringQueryOperatorInput
}

input Activity_FileInfoFilterInput {
    directory: StringQueryOperatorInput
    extension: StringQueryOperatorInput
    name: StringQueryOperatorInput
    path: StringQueryOperatorInput
}

input AudreyFilterInput {
    content: StringQueryOperatorInput
    fileInfo: Audrey_FileInfoFilterInput
    id: IDQueryOperatorInput
    path: StringQueryOperatorInput
}

input Audrey_FileInfoFilterInput {
    directory: StringQueryOperatorInput
    extension: StringQueryOperatorInput
    name: StringQueryOperatorInput
    path: StringQueryOperatorInput
}

input BelongsToFilterInput {
    id: IDQueryOperatorInput
    path: StringQueryOperatorInput
    typeName: TypeNameQueryOperatorInput
}

input IDQueryOperatorInput {
    "Filter by property of (strict) equality."
    eq: ID
    "Filter nodes that contain the field, including nodes where the field value is null."
    exists: Boolean
    "Filter by property matching any of the provided values."
    in: [ID]
    "Filter by property not equal to provided value."
    ne: ID
    "Filter by property not matching any of the provided values."
    nin: [ID]
}

input ImageQueryOperatorInput {
    "Filter by property of (strict) equality."
    eq: Image
    "Filter nodes that contain the field, including nodes where the field value is null."
    exists: Boolean
    "Filter by property matching any of the provided values."
    in: [Image]
    "Filter by property not equal to provided value."
    ne: Image
    "Filter by property not matching any of the provided values."
    nin: [Image]
    "Filter by property matching provided regular expression."
    regex: String
}

input JSONQueryOperatorInput {
    "Filter by property of (strict) equality."
    eq: JSON
    "Filter nodes that contain the field, including nodes where the field value is null."
    exists: Boolean
    "Filter by property matching any of the provided values."
    in: [JSON]
    "Filter by property not equal to provided value."
    ne: JSON
    "Filter by property not matching any of the provided values."
    nin: [JSON]
    "Filter by property matching provided regular expression."
    regex: String
}

input MairieFilterInput {
    content: StringQueryOperatorInput
    fileInfo: Mairie_FileInfoFilterInput
    id: IDQueryOperatorInput
    path: StringQueryOperatorInput
}

input Mairie_FileInfoFilterInput {
    directory: StringQueryOperatorInput
    extension: StringQueryOperatorInput
    name: StringQueryOperatorInput
    path: StringQueryOperatorInput
}

input PageFilterInput {
    context: JSONQueryOperatorInput
    path: StringQueryOperatorInput
}

input PhotoboothFilterInput {
    content: StringQueryOperatorInput
    fileInfo: Photobooth_FileInfoFilterInput
    id: IDQueryOperatorInput
    path: StringQueryOperatorInput
}

input Photobooth_FileInfoFilterInput {
    directory: StringQueryOperatorInput
    extension: StringQueryOperatorInput
    name: StringQueryOperatorInput
    path: StringQueryOperatorInput
}

input SortArgument {
    by: String! = "date"
    order: SortOrder = DESC
}

input StringQueryOperatorInput {
    "Filter by property of (strict) equality."
    eq: String
    "Filter nodes that contain the field, including nodes where the field value is null."
    exists: Boolean
    "Filter by property matching any of the provided values."
    in: [String]
    "Filter by property not equal to provided value."
    ne: String
    "Filter by property not matching any of the provided values."
    nin: [String]
    "Filter by property matching provided regular expression."
    regex: String
}

input TeamFilterInput {
    content: StringQueryOperatorInput
    excerpt: StringQueryOperatorInput
    fileInfo: Team_FileInfoFilterInput
    id: IDQueryOperatorInput
    mail: StringQueryOperatorInput
    name: StringQueryOperatorInput
    path: StringQueryOperatorInput
    picture: ImageQueryOperatorInput
    telephone: StringQueryOperatorInput
}

input Team_FileInfoFilterInput {
    directory: StringQueryOperatorInput
    extension: StringQueryOperatorInput
    name: StringQueryOperatorInput
    path: StringQueryOperatorInput
}

input TypeNameQueryOperatorInput {
    "Filter by property of (strict) equality."
    eq: TypeName
    "Filter nodes that contain the field, including nodes where the field value is null."
    exists: Boolean
    "Filter by property matching any of the provided values."
    in: [TypeName]
    "Filter by property not equal to provided value."
    ne: TypeName
    "Filter by property not matching any of the provided values."
    nin: [TypeName]
}


scalar Image

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

scalar Date

scalar File
